# CÃ³mo empezar con Docker Compose

This tutorial introduces **Docker Compose** as a solution to simplify the management of multi-component applications running in Docker containers. Previously, deploying such applications required executing numerous Docker commands manually, remembering the correct order, managing networks, volumes, dependencies, and configurations like environment variables and ports. Docker Compose allows defining the entire application environment in a single configuration file (typically `compose.yaml`) and launching it with a single command, automating the setup and addressing dependencies. The goal is to demonstrate how Docker Compose streamlines the process of bringing up complex application environments, like the 'Tour of Heroes' example with its database, API, and web components.

## 1. Core Concepts

- **Problem with Manual Docker Commands:** Manually launching multi-container applications requires executing many commands in a specific order to ensure dependencies are met, networks are created, volumes are attached, and configurations are applied. This process can be tedious and error-prone.
- **Docker Compose:** A tool that simplifies the definition and running of multi-container Docker applications. It uses a single YAML file to configure all application services.
- **`compose.yaml`:** The default name for the Docker Compose configuration file. In older versions, this file was typically named `docker-compose.yaml`, and that name is still supported for compatibility.
- **Services:** The top-level section in `compose.yaml` where you define each container (or service) that is part of your application. Each service is listed under this section with a unique name.
- **Image (`image`):** Specifies the Docker image to use for a service. This can be an image from a registry like Docker Hub.
- **Build (`build`):** Instead of using a pre-built image, you can specify a path to a directory containing a `Dockerfile`. Docker Compose will build the image before starting the service.
- **Build Context (`context`) and Dockerfile Name (`dockerfile`):** When using `build`, you can specify the build context (the directory containing the files) and, if the `Dockerfile` is not named `Dockerfile` by default, the specific filename to use.
- **Ports (`ports`):** Used to map ports between the host machine and the container. For example, `8080:80` maps port 80 inside the container to port 8080 on the host.
- **Environment Variables (`environment`):** Allows setting environment variables within the container. This is useful for configuration, like database credentials or connection strings, without modifying the application code.
- **Networking:** Containers defined in the same `compose.yaml` file automatically join a default network, allowing them to communicate with each other using their service names as hostnames.
- **Custom Networks (`networks`):** You can define custom networks in the `networks` section of `compose.yaml`. Services can then be explicitly assigned to these networks. By default, custom networks use the `bridge` driver.
- **Volumes (`volumes`):** Used to persist data generated by and used by Docker containers. You can define named volumes in the `volumes` section and then map them to paths inside service containers.
- **Dependencies (`depends_on`):** Specifies the dependencies between services. Docker Compose ensures that dependent services are started before the services that rely on them. This helps avoid errors caused by services trying to connect to others that aren't yet running.
- **Watch (`develop.watch`):** A relatively new feature that allows Docker Compose to monitor specified paths for code changes. If changes are detected, it can automatically rebuild the corresponding service image.
- **Profiles (`profiles`):** Allows defining different sets of services that can be started together. A service can be assigned to one or more profiles. Services without an explicit profile are always included. You can choose which profiles to activate when running `docker compose up`.

## 2. Practical Steps: Hands-on Guide

The `compose.yaml` file typically contains several top-level keys to organize your application's configuration.

**Defining Your Application Services**

The core of the `compose.yaml` file is where you define the services that make up your application. Each service corresponds to a container, and you specify its configuration details here.

Here's how the services for the Tour of Heroes application are defined:

- **The Database Service (`db`)**
  This service represents your database container, which is essential for the API to function.

  - It uses a specified **Docker image**, in this case, `azure-sql-edge`. The version or tag of the image is also specified.
  - **Environment variables** are set to configure the database. For the `azure-sql-edge` image, this includes accepting the End-User License Agreement and setting a strong administrator password .
  - To ensure the database data persists even if the container is removed and recreated, a **volume** is used to map a named volume from the Docker host to the directory inside the container where the database stores its files (`/var/opt/mssql`).
  - The database container is connected to a **custom network** so that other services, like the API, can communicate with it using its service name (`db`).

    ```yaml
    services:
    db:
      image: mcr.microsoft.com/azure-sql-edge:latest
      environment:
        - ACCEPT_EULA=Y
        - SA_PASSWORD=Password123!
      volumes:
        - db-data:/var/opt/mssql
      networks:
        - tour-of-heroes-vnet
    ```

- **The API Service (`api`)**
  This service represents your .NET API application.

  - Since you have the source code and need to build a custom image, you use the **`build` property**, providing the path to the directory containing the API project and Dockerfile (`tour-of-heroes-api`). Docker Compose will build the image from this context.
  - **Ports** are mapped to allow access to the API from outside the container. Host port `5051` is mapped to container port `5000`, where the API is listening.
  - The API needs to connect to the database. The database **connection string is configured using an environment variable**. .NET applications can use a specific environment variable format (`ConnectionStrings__DefaultConnection`) to represent nested configuration like that found in `appsettings.json`. The connection string uses the service name `db` as the server address because services on the same network can resolve each other by name. The correct database name, user ID, and password must be included.
  - A **dependency** is set on the `db` service using `depends_on`. This ensures that the database container is started and potentially ready before the API container starts, although `depends_on` primarily controls the startup order, not necessarily application readiness.
  - The API container is also connected to the **custom network** to communicate with the database and the web service.
  - For development purposes, the **`develop` section with the `watch` property** is used. By specifying the path to the API source directory (`tour-of-heroes-api`), Docker Compose can detect changes in the source code, automatically rebuild the image, and restart the container, providing a live development experience.

    ```yaml
    api:
        depends_on:
        - db
        build: tour-of-heroes-api
        ports:
        - 5051:5000
        environment:
        - ConnectionStrings__DefaultConnection=Server=db,1433;Initial Catalog=heroes;Persist Security Info=False;User ID=sa;Password=Password123!;Encrypt=False
        networks:
        - tour-of-heroes-vnet
        develop:
        watch:
            - action: rebuild
            path: tour-of-heroes-api/.
    ```

- **The Web Service (`web`)**
  This service represents your Angular frontal application.

  - It also uses the **`build` property** to create an image from source.
  - Since the Dockerfile for the web application doesn't have the default name (`Dockerfile`), you specify both the **`context`** (the project directory, `tour-of-heroes-angular`) and the **specific `dockerfile` name** (`dockerfile-github-copilot`) within that context.
  - **Ports** are mapped, connecting host port `8080` to container port `80`, where the web server (likely Nginx serving the static files) is listening.
  - The web application **depends on the API service** to retrieve data, so `depends_on: - api` is used.
  - The web container is connected to the **custom network** to communicate with the API.
  - Similar to the API, the **`develop` section with `watch`** is configured for the web service, pointing to its source directory (`tour-of-heroes-angular`). This enables automatic rebuilds and restarts upon code changes for live development.

    ```yaml
    web:
        depends_on:
        - api
        build:
        context: tour-of-heroes-angular
        dockerfile: dockerfile-github-copilot
        ports:
        - 8080:80
        networks:
        - tour-of-heroes-vnet
        develop:
        watch:
            - action: rebuild
            path: tour-of-heroes-angular/.
    ```

- **The Fake Caller Service (`fake-caller`)**
  This is an optional utility service used for testing or debugging, which periodically calls the API endpoint.

  - It is configured to run only under a specific **profile**, in this case, `debug`. Services assigned to a profile are only started when that profile is explicitly activated using the `--profile` flag with the `docker compose up` command.
  - It **depends on the API** (`depends_on: - api`) as it needs the API to be running to make calls.
  - It uses a pre-built image like `appropriate/curl` which contains the `curl` tool.
  - The **`entrypoint`** defines the command the container runs: a script that uses `curl` to make GET requests to `http://api:5000/api/hero` every 0.5 seconds. Notice it uses the service name `api` to reach the API container within the network.
  - It is connected to the **custom network** to communicate with the API service.

  ```yaml
  fake-caller:
    depends_on:
      - api
    image: alpine/curl:latest
    entrypoint:
      - /bin/sh
      - -c
      - |
        sleep 5
        while true; do 
          curl -o /dev/null -s -w "%{http_code}\n" "http://api:5000/api/hero" || true
          sleep 0.5
        done
    networks:
      - tour-of-heroes-vnet
    profiles: [debug]
  ```

**Defining Persistent Data Volumes**

To ensure that your database data is not lost when the container is stopped, removed, or recreated, you define a **named volume**. Named volumes are managed by Docker and provide a way to persist data outside the lifecycle of a single container.

The `volumes` section is where you define these named volumes:

```yaml
volumes:
  db-data:
```

Here, `db-data` is the name of the volume. It indicates that you're using a basic named volume with default settings. This volume is then referenced in the `db` service configuration to mount it to the database's data directory.

**Defining Custom Networks**

While Docker Compose automatically creates a default network for services defined in the same file, defining a **custom network** explicitly allows for more control and clear naming. Containers on the same Docker Compose network can communicate with each other using their service names as hostnames.

```yaml
networks:
  tour-of-heroes-vnet:
```

Here, `tour-of-heroes-vnet` is the name of the network. It indicates that you're using the default network driver, which is `bridge`. All services that need to communicate with each other (`db`, `api`, `web`, `fake-caller`) must be explicitly attached to this network.

See the full `compose.yaml` file [here](./lesson-07/compose.yaml)

**Executing Your Application Environment**

With the `compose.yaml` file created, you can **launch your entire application environment with a single command** from the terminal in the directory where the file is located:

- To build images (if necessary) and start all services that are not assigned to a specific profile, or are assigned to a profile that is active by default (which is usually none unless configured otherwise), run:

  ```bash
  docker compose up
  ```

  This command will follow the dependencies defined by `depends_on`. By default, `docker compose up` runs in the foreground, displaying the logs from all containers. To run in the background, you can add the `-d` flag (information not explicitly in sources, but standard Docker Compose usage).

- To include services assigned to a specific profile (like the `fake-caller` service with the `debug` profile), use the `--profile` flag:

  ```bash
  docker compose --profile debug up
  ```

  This command activates the `debug` profile, causing the `fake-caller` service to be included along with the default services.

- When running `docker compose up` with the `develop.watch` configuration enabled for services, you can press the `W` key after the services start to enable watch mode. Docker Compose will then monitor the specified source directories for changes. If a change is detected, it will automatically rebuild the image and restart the corresponding service's container.

- To stop and remove the containers, networks, and volumes defined in the `compose.yaml` file (named volumes are typically kept by default), you can use the `docker compose down` command (information not explicitly in sources, but standard Docker Compose usage demonstrated by stopping with Ctrl+C).

Using Docker Compose significantly **reduces the complexity** compared to manually executing multiple `docker run`, `docker network create`, and `docker volume create` commands in the correct order. It encapsulates your environment's requirements in one easy-to-manage file.
